##################################################### 枚举幂集（枚举子集）
#####################################################
s = 0b1001101
""" 枚举非空子集 """
sub = s
while sub:
    print(sub) # 对该子集的决定
    sub = s & (sub - 1)


""" 枚举s的子集 （含空集）"""
sub = s
while True:
    # 处理 sub 的逻辑
    sub = (sub - 1) & s
    if sub == s:
        break
#####################################################
#####################################################
##################################################### 枚举集合内元素
#####################################################
n = 30
""" 最普通的枚举元素，检查存在 """
for i in range(n):
    if (s >> i) & 1:  # i 在 s 中
        # 处理 i 的逻辑
        pass

""" 不断剔除最小的元素，直到集合为空 （去掉lowbit的递推可以也用在子集递推上）"""
t = s
while t:
    lowbit = t & -t
    t ^= lowbit
    i = lowbit.bit_length() - 1
    # 处理 i 的逻辑
#####################################################
#####################################################
##################################################### 计算lowbit 删除s内最小元素
#####################################################

##
s = s & (s-1) # 删除最小元素，s-1 即删掉了s最低位，and S 去掉低位1

lb = s & -s # lowbit/s 中最小元素

~s + 1 #会反转s 然后，将lowbit还原, s and 他就得到了lowbit 高位全是对称反转，只有lowbit对上 低位全是0
       # s & (-s + 1) == lowbit
       # 而他又正好是-s 根据补码的定义
       # 所以有 s & -s == lowbit

## 预处理子集的和
# 预处子集和
nums = [0,1,2,3,4]
g = [0] * (1 << n)
for s in range(1, 1 << n):  # for s in range(1<<n): 不能从0开始，否则吧net[-1] 算进去了
    lb = s & -s
    g[s] = g[s - lb] + nums[lb.bit_length() - 1]

""" 常见位运算技巧分类总结
https://leetcode.cn/circle/discuss/CaOJ45/


1. 为什么 sub = (sub - 1) & s 可以迭代子集
    迭代整体集合 s=111111 的子集:
    s = s - 1 
    就是二进制减法，如果是对s=101101 则每次 (sub-1) & s 即可将减法限制在s内
    https://leetcode.cn/circle/discuss/CaOJ45/

2. 枚举子集的复杂度 （幂集枚举 二进制减法）
    2^bit_count() 的幂集
    从二进制减法角度思考, 不超过s进行二进制减法 （因为是在s内部进行） 所以复杂度不超过数值 s （lc982的复杂度分析）

"""