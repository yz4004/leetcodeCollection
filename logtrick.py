from collections import defaultdict
from typing import List


def logTrick(nums: List[int], op):
    cnt = defaultdict(int)
    f = [] # [i,j,v] 区间 [i:j]/[i,j) 和对应的连续运算的结果v
    for i, x in enumerate(nums): # 当前考虑以x为右边界的所有子数组
        for v in f:
            v[2] = op(v[2], x)
        f.append([i, i+1, x])

        # 执行去重
        k = 0 # 保留数组的结尾 k]
        for v in f[1:]:
            if f[k][2] == v[2]:
                f[k][1] = v[1] #每次保留最大的区间范围（延展到最右侧）
            else:
                k += 1
                f[k] = v #每次保留最大的区间范围（延展到最右侧）
        f = f[:k+1]

        for v in f:
            cnt[v[2]] += v[1] - v[0] #等于该值的子数组数量 (如果是更新最大值 就在上面去重过程中更新
    return cnt


"""


抽象出合适的阶梯模型：（以连续and为例）

    每一次循环节，会继承的是以【前一个元素为右边界的，一条单调递增的无重复的数列】，最大的阶梯高点就是 x （当前循环节的上一个元素）
    假如没有去重，则会观察到一个阶梯一样的单增数列 但阶梯会很长，总长度是 O(n) 的，去重后只保留每个阶梯的代表元
    每个元素是阶梯的分割点，即原来阶梯的最长的位置，或者说最大的连续区间 区间值为 t，再往前长一点就下降了，所有区间以当前遍历的值为右端点结尾

每一次循环节: 求阶梯 + 缩减阶梯 （以连续and为例）
    每次对于i 先与之前所有的 (0,i-1) (1,i-1) ... (i-1,i-1) 结合一遍得到
    (0,i) (1,i) ... (i-1,i) 
    再附上 (i,i)
    这得到了一个单调递增（从左往右）的阶梯数组，然后我们需要按阶梯高度合并之，每个高度的阶梯再保存一个坐标信息记录阶梯范围
    
          ____     ...3  f[i]  = [height_i, start_i]
    _____|    ...1       f[i-1]
         * 
    假如这个阶梯高度一个3一个1，我们保存3高度那个阶梯的 * 位置作为坐标辨识 start_i，
    而下一个阶梯起点为 f[i+1][1]
    则3高度阶梯范围 [f[i][1], f[i+1][1])
    
    （note: 假如已经是当前遍历 i] 的所在高度，则阶梯没有搜索完全，还不能记录当前阶梯的最长长度，但可以更新子数组数量）


题单 leetcode
    3097, 3209, 3171, 1521, 898 直接套模板 
    2411 改写一下模板倒叙理解容易

模板来源：
    第 400 场周赛 排名 - 力扣（LeetCode） 不造轮子
"""