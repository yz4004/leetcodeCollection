from collections import defaultdict
from typing import List
from math import  gcd

######################################################################################################################################
######################################################################################################################################
# 双指针去重模板 （下面例题有set去重模板）
def logTrick(nums: List[int], op):
    cnt = defaultdict(int)
    f = [] # [i,j,v] 区间 [i:j]/[i,j) 和对应的连续运算的结果v
    for i, x in enumerate(nums): # 当前考虑以x为右边界的所有子数组
        # 1. 当前新加入的元素x 与刚刚 i-1] 结尾的子数组的所有logtrick子数组值运算
        for v in f:
            v[2] = op(v[2], x)
        f.append([i, i+1, x])

        # 2. 双指针执行去重
        k = 0 # 保留数组的结尾 k]
        for v in f[1:]:
            if f[k][2] == v[2]:
                f[k][1] = v[1] #每次保留最大的区间范围（延展到最右侧）
            else:
                k += 1
                f[k] = v #每次保留最大的区间范围（延展到最右侧）
        f = f[:k+1]

        # 3. 遍历以i]结尾的所有unique的子数组值 更新结果. 此时f内的值不超过log级别
        for v in f:
            cnt[v[2]] += v[1] - v[0] #等于该值的子数组数量 (如果是更新最大值 就在上面去重过程中更新
    return cnt
######################################################################################################################################
######################################################################################################################################




######################################################################################################################################
######################################################################################################################################
""" logtrick 例题 - 求最大的子数组gcd-sum. 
- 求最大的子数组gcd-sum. 
1. 要求子数组长度 >= k
2. 子数组的gcd-sum定义为 gcd * sum
3. 求上述最大

- LC2941 https://leetcode.cn/problems/maximum-gcd-sum-of-a-subarray/

1. 子数组端点、sum、gcd都要保存 
2. 两种方法，数组除重、set/map 除重
"""
def maxGcdSum(self, nums: List[int], k: int) -> int:


    # 枚举子数组的gcd - log trick
    #
    s = []
    res = 0
    for idx, x in enumerate(nums):

        # [gcd, j, sum] 数字每个entry保持三种信息，gcd 最远取得该gcd的左端点j 区间和
        # 数组由远及近保持 最远到最近的子数组
        # 与当前x求完一轮gcd后 数组元素都不会增加 可能造成一批重复，下面利用数组双指针除重
        for j in range(len(s)):
            # [j:i]
            s[j][0] = gcd(s[j][0], x)
            s[j][2] += x
        s.append([x, idx, x])

        # 除重
        i = 1
        for j in range(1, len(s)):
            if s[j][0] != s[i - 1][0]:
                s[i] = s[j]
                i += 1
        s = s[:i]

        # 遍历更新结果，计算最大gcd-sum
        for j in range(len(s)):
            if idx - s[j][1] + 1 >= k:
                res = max(res, s[j][0] * s[j][2])  # gcd * sum
    return res

    # 懒人思维版 利用set除重
    ps = list(itertools.accumulate(nums, initial=0))
    s = {}
    res = 0
    for i, x in enumerate(nums):

        t = {x: i}
        for y, j in s.items():
            # [j:i]
            t[gcd(x, y)] = j
        s = t

        for d, j in s.items():
            if i - j + 1 >= k:
                res = max(res, d * (ps[i + 1] - ps[j]))
    return res
######################################################################################################################################
######################################################################################################################################





######################################################################################################################################
######################################################################################################################################
# 模板解析
"""


抽象出合适的阶梯模型：（以上文模板连续and为例）

    每一次循环节，会继承的是以【前一个元素为右边界的，一条单调递增的无重复的数列】，最大的阶梯高点就是 x （当前循环节的上一个元素）
    假如没有去重，则会观察到一个阶梯一样的单增数列 但阶梯会很长，总长度是 O(n) 的，去重后只保留每个阶梯的代表元
    每个元素是阶梯的分割点，即原来阶梯的最长的位置，或者说最大的连续区间 区间值为 t，再往前长一点就下降了，所有区间以当前遍历的值为右端点结尾

每一次循环节: 求阶梯 + 缩减阶梯 （以连续and为例）
    每次对于i 先与之前所有的 (0,i-1) (1,i-1) ... (i-1,i-1) 结合一遍得到
    (0,i) (1,i) ... (i-1,i) 
    再附上 (i,i)
    这得到了一个单调递增（从左往右）的阶梯数组，然后我们需要按阶梯高度合并之，每个高度的阶梯再保存一个坐标信息记录阶梯范围

          ____     ...3  f[i]  = [height_i, start_i]
    _____|    ...1       f[i-1]
         * 
    假如这个阶梯高度一个3一个1，我们保存3高度那个阶梯的 * 位置作为坐标辨识 start_i，
    而下一个阶梯起点为 f[i+1][1]
    则3高度阶梯范围 [f[i][1], f[i+1][1])

    （note: 假如已经是当前遍历 i] 的所在高度，则阶梯没有搜索完全，还不能记录当前阶梯的最长长度，但可以更新子数组数量）


题单 leetcode
    3097, 3209, 3171, 1521, 898 直接套模板 
    2411 改写一下模板倒叙理解容易

模板来源：
    第 400 场周赛 排名 - 力扣（LeetCode） 不造轮子
"""