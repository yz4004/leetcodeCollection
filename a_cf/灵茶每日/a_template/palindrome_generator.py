"""
顺序生成9位数以内回文数 [1 - 99999_9999]

- 枚举回文的左半部分, 同时生成 2*k-1, 2*k 的回文数
    123 -> 12321, 123321
- 下次考虑 k+1 的左半部分，会同时生成 2*k+1, 2*k+2, 这正好是位数从小到大
- 利用base作为左半部分每次循环的出发元素，考虑 [base, base*10] （base每次是最小的k位元素 1/10/100..。）
"""
######################### 模板框架
"""
生成范围      枚举的左半边 [base, base*10)     base
1-9         1-9                            1       odd  将枚举的左半边反转后拼接，去掉中间一个
11-99       1-9                                    even 将枚举的左半边反转后拼接
101-999     10-99                          10
1001-9999   10-99                  
10001-99999 100-999                        100
...
"""

## 给定数字生成
def generate(MX):
    pal = []
    base = 1  # 每次循环节生成 [base, base*10]
    # 1 10 100 ...
    # base=1  1-9 11-99
    # base=10 101...999 1001...9999
    # ...
    # base=1e5 能生成 9位/10位所有回文数
    while True:

        for i in range(base, base * 10):
            x = i       #左半部分，每次对下面的t求个位数然后拼到x后面
            t = i // 10 #奇数要跳过中间的数
            while t:
                x = 10 * x + (t % 10)
                t //= 10
            if x > MX:
                return pal
            pal.append(x)

        if base > 10000: break # 如果base为10000 只生成了奇数 即9位数回文，这里截断
        # 偶数
        for i in range(base, base * 10):
            x = i  # 同上，只是不跳过第一个个位了
            t = i
            while t:
                x = 10 * x + (t % 10)
                t //= 10
            if x > MX:
                return pal
            pal.append(x)
        base *= 10
generate(int(1e9))

### 给定字符串生成
# 枚举n=4位数长度的回文数
# https://leetcode.cn/problems/find-the-count-of-good-integers/solutions/2899725/mei-ju-suo-you-hui-wen-shu-zu-he-shu-xue-3d35/

####################### 预处理回文数的题目
"""
2967. 使数组成为等数数组的最小代价 （找离中位数最近的回文数，预处理后二分，或者两侧遍历枚举）
906. 超级回文数 （分析范围后枚举枚举范围）
866. 回文质数 （可以挨个生成再检查质数，但有些数学优化 - 所有偶数长度回文数，除了11都可以被11整除
2081. k 镜像数字的和 （先枚举k进制最好）
564. 寻找最近的回文数 （不是预处理题目，但是涉及到回文数生成过程中的增长规律）
3272. 统计好整数的数目 (生成回文数后，再考虑其所有排列，即数通过重排可以重构这个回文数）
3766. 将数字变成二进制回文数的最少操作 (二进制回文数生成)
"""

####################### 递推顺序生成回文数的间隔问题 解决最近的回文数564问题
"""
递推顺序生成回文数的间隔问题
肯定是从中心开始增加最好，因为如果从低位增加高位也对称增加，反而更大，从中心增加是最小的

1. 最一般的情况，中心增加不进位
    ... y  x  x   y  
    ... y x+1 x+1 y ...  差值 11.... 需要增加回文数一半的长度左右 （此时其实是 相同位数下 生成回文数序列最大间隔的时刻）
    
2. 中心增加发生一次进位
    ...   y  9 9  y   ...     发生了进位
    ...(y+1) 0 0 (y+1) ....   11.... 仍然是一半回文数长度 （同上）

3. 中心增加发生更多的进位
    ...   y  9 9 9 9  y   ...      发生了进位
    ...(y+1) 0 0 0 0  (y+1) ....   11.... 需要的短于一半回文数长度 （进位越多越短）

4. 外层也是9 即全是9 外侧无y
    当y为9且打头 再进位 外侧没有可以加一的数，就需要补位了 （此时进位仅为2，生成回文数序列前后差最小的时刻）
    只需要加2
    9 -> 11
    99 -> 101
    999 -> 1001
    9...9 -> 10...01 
    
结论，生成回文数序列 发生进位越多增长越小，而回文数增长最大的就是一般情况下的中心增长，增加为 11... 回文长度的一半左右

（上面是对偶数讨论，实际上奇数更小
讨论三种长度下，回文数最大增加的距离
2k-1   1...  总长度为k
2k     11... 总长度为k+1
2k+1   1...  总长度为k+1

    所以发现偶数长度是最大的 [2k] > [2k+1] > [2k-1] 
    偶数长度回文串，最大增长是最大的 为 11... [k+1总长度 （总长为2k）] 大于比他还长一位的奇数
    ... 2k+2 2k+3 2k 2k+1 2k-2 2k-1 
    6 . 4 5 2 3 1
    这样错开一位
    6   4   2  
      7   5   3  1
     
    

一个具体的示例：
    121
    131 10
    
    1221 
    1331 110
    
    11211
    11311 100
    
解决题目 564
564. 寻找最近的回文数 https://leetcode.cn/problems/find-the-closest-palindrome/
如果x本身也是回文数，仍不能考虑其本身，而是挑选附近最近的回文数
考虑中心x x+1 x-1 的翻转，还要考虑退位进位的情况 详细见：

"""