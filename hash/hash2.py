class Solution:
    # print(ord("0")) 48

    def equalDigitFrequency(self, s: str) -> int:
        base = 499  # 233 131 1313131
        M = 100_000_0000 + 7  # pow(2, 63)-1  pow(2, 64) -1

        n = len(s)
        f = [0] * (n + 1)
        # f[i] = [:i]

        cnt = [[0] * (n + 1) for _ in range(10)]
        for i in range(n):
            # []
            f[i + 1] = (f[i] * base + ord(s[i]) - ord("0") + 1) % M
            for j in range(10):
                cnt[j][i + 1] = cnt[j][i] + (ord(s[i]) - ord("0") == j)

        # print("max - ", sys.maxsize)
        # max -  9223372036854775807

        values = []
        for i in range(n):
            for j in range(i + 1, n + 1):
                # [i,j)
                # hashcode = f[j] - f[i] * base ** (j-i)

                # 遍历当前子数组的所有字母，统计freq，期待所有非0的人freq相等，如果发现不相等则跳过
                freq = -1
                valid = True
                for k in range(10):
                    t = cnt[k][j] - cnt[k][i]
                    if t == 0: continue
                    if freq != -1 and t != freq:
                        valid = False
                        break
                    elif freq == -1:
                        freq = t

                if valid == False: continue

                # hashcode = (f[j] - f[i] * pow(base, (j-i), M) % M ) % M # -- 最稳 在每个可能溢出的地方取模 其他题也能用得上
                # hashcode = (f[j] - f[i] * pow(base, (j-i), M)) % M  --- 也能过 虽然乘法不取模不安全 如果是c++/java的自然移除则无妨，python范围更大也无妨
                # hashcode = (f[j] - (f[i] * pow(base, (j-i), M)) % M + M) % M
                hashcode = f[j] - f[i] * pow(base, (j - i), M) % M
                # 底下的相减，在全是0的情况下，超出了Mod的范围 2^64也不行，实际是取模只取了后半部分乘法，没带上前面的加减法，不取模造成了错误
                # 每个乘法都去了模 但是加减法没取模，导致两个 1e9+7 以内的数的运算 仍可能超过 1e7
                # 虽然这个加上的数远在python最大整数范围内，但是哈希函数的运算规则被破坏了，这个字符的哈希值 没有被映射到 1e9+7的值域范围内
                # 取模 + M 防止负数 再取模 其实不必要 这里负数也是表示状态
                values.append(hashcode)

        print(max(values))
        print(values)
        values.sort()
        res = 1
        for i in range(1, len(values)):
            res += values[i] != values[i - 1]
        return res
if __name__ == "__main__":
    sol = Solution()
    s = "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    result = sol.equalDigitFrequency(s)
    print(result)
