"""
按大小生成 10^5以内的 palindrome [1 - 99999]

- 枚举回文的左半部分, 同时生成 2*k-1, 2*k 的回文数
    123 -> 12321, 123321
- 下次考虑 k+1 的左半部分，会同时生成 2*k+1, 2*k+2, 这正好是位数从小到大
- 利用base作为左半部分每次循环的出发元素，考虑 [base, base*10] （base每次是最小的k位元素 1/10/100..。）
"""
######################### 模板框架
"""
pal = []
base = 1 # 每次循环节生成 [base, base*10]
while base < 10 ** 5: # 枚举长度上限，即我们接受5及以下的回文数

    for i in range(base, base*10):
        ## 将左半部分(i) 反转拼接
        pass
    # 偶数
    for i in range(base, base * 10):
        pass
    base *= 10
"""
########################### 实现填充
pal = []
base = 1  # 每次循环节生成 [base, base*10]
while base < 10 ** 5:  # 枚举长度上限，即我们接受5及以下的回文数

    for i in range(base, base * 10):
        x = i       #左半部分，每次对下面的t求个位数然后拼到x后面
        t = i // 10 #奇数要跳过中间的数
        while t:
            x = 10 * x + (t % 10)
            t //= 10
        pal.append(x)

    if base > 10000: break
    # 偶数
    for i in range(base, base * 10):
        x = i  # 同上，只是不跳过第一个个位了
        while t:
            x = 10 * x + (t % 10)
            t //= 10
        pal.append(x)
    base *= 10
print(pal[:100])

####################### 预处理回文数的题目
"""
2967. 使数组成为等数数组的最小代价 （找离中位数最近的回文数，预处理后二分，或者两侧遍历枚举）
906. 超级回文数 （分析范围后枚举枚举范围）
2081. k 镜像数字的和 （先枚举k进制最好）
564. 寻找最近的回文数 （不是预处理题目，但是涉及到回文数生成过程中的增长规律）

"""

####################### 递推顺序生成回文数的间隔问题 解决最近的回文数564问题
"""
递推顺序生成回文数的间隔问题
肯定是从中心开始增加最好，因为如果从低位增加高位也对称增加，反而更大，从中心增加是最小的

1. 最一般的情况，中心增加不进位
    ... y  x  x   y  
    ... y x+1 x+1 y ...  差值 11.... 需要增加回文数一半的长度左右 （此时其实是 相同位数下 生成回文数序列最大间隔的时刻）
    
2. 中心增加发生一次进位
    ...   y  9 9  y   ...     发生了进位
    ...(y+1) 0 0 (y+1) ....   11.... 仍然是一半回文数长度 （同上）

3. 中心增加发生更多的进位
    ...   y  9 9 9 9  y   ...      发生了进位
    ...(y+1) 0 0 0 0  (y+1) ....   11.... 需要的短于一半回文数长度 （进位越多越短）

4. 外层也是9 即全是9 外侧无y
    当y为9且打头 再进位 外侧没有可以加一的数，就需要补位了 （此时进位仅为2，生成回文数序列前后差最小的时刻）
    只需要加2
    9 -> 11
    99 -> 101
    999 -> 1001
    9...9 -> 10...01 
    
结论，生成回文数序列 发生进位越多增长越小，而回文数增长最大的就是一般情况下的中心增长，增加为 11... 回文长度的一半左右

（上面是对偶数讨论，实际上奇数更小
讨论三种长度下，回文数最大增加的距离
2k-1   1...  总长度为k
2k     11... 总长度为k+1
2k+1   1...  总长度为k+1

    所以发现偶数长度是最大的 [2k] > [2k+1] > [2k-1] 
    偶数长度回文串，最大增长是最大的 为 11... [k+1总长度 （总长为2k）] 大于比他还长一位的奇数
    ... 2k+2 2k+3 2k 2k+1 2k-2 2k-1 
    6 . 4 5 2 3 1
    这样错开一位
    6   4   2  
      7   5   3  1
     
    

一个具体的示例：
    121
    131 10
    
    1221 
    1331 110
    
    11211
    11311 100
    
解决题目 564
564. 寻找最近的回文数
如果x本身也是回文数，仍不能考虑其本身，而是挑选附近最近的回文数
考虑中心x x+1 x-1 的翻转，还要考虑退位进位的情况 详细见：
https://leetcode.cn/problems/find-the-closest-palindrome/
"""